name: CI

on:
  push:
    branches:
      - main
      - 'feature/**'
  pull_request:
    branches:
      - main
      - 'feature/**'

jobs:
  ci:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    strategy:
      matrix:
        node-version: [20.x]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Setup Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: 'jobs/requirements.txt'

      - name: Install Node.js dependencies
        run: npm ci

      - name: Type-check and build API
        run: |
          npm run build

      - name: Install Python dependencies
        run: |
          pip install -r jobs/requirements.txt

      - name: Setup CI environment
        run: |
          # Copy CI environment variables
          cp .env.ci .env

      - name: Start PostgreSQL
        run: |
          docker compose up -d postgres

      - name: Wait for PostgreSQL to be ready
        run: |
          echo "Waiting for PostgreSQL to be ready..."
          for i in {1..30}; do
            if docker compose ps postgres | grep -q "healthy"; then
              echo "PostgreSQL is healthy!"
              break
            fi
            if [ "$i" -eq 30 ]; then
              echo "ERROR: PostgreSQL did not become healthy"
              docker compose logs postgres
              exit 1
            fi
            echo "Waiting... (attempt $i/30)"
            sleep 2
          done

      - name: Verify database migrations
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGDATABASE: smart_inventory
          PGUSER: postgres
          PGPASSWORD: postgres
        run: |
          echo "Verifying database schemas..."
          SCHEMA_COUNT=$(PGPASSWORD="${PGPASSWORD}" psql -h "${PGHOST}" -p "${PGPORT}" -U "${PGUSER}" -d "${PGDATABASE}" -tAc "SELECT count(*) FROM information_schema.schemata WHERE schema_name IN ('raw', 'curated', 'ops');")
          if [ "$SCHEMA_COUNT" -eq 3 ]; then
            echo "✓ All required schemas exist (raw, curated, ops)"
          else
            echo "✗ Expected 3 schemas, found $SCHEMA_COUNT"
            exit 1
          fi

      - name: Build and start API container
        run: |
          docker compose build api
          docker compose up -d api

      - name: Wait for API health
        run: |
          echo "Waiting for API to be healthy..."
          for i in {1..30}; do
            if curl -f http://localhost:3000/health > /dev/null 2>&1; then
              echo "API is healthy!"
              break
            fi
            if [ "$i" -eq 30 ]; then
              echo "ERROR: API did not become healthy"
              docker compose logs api
              exit 1
            fi
            echo "Waiting... (attempt $i/30)"
            sleep 2
          done

      - name: Run data ingestion job (small dataset for CI)
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGDATABASE: smart_inventory
          PGUSER: postgres
          PGPASSWORD: postgres
        run: |
          echo "Running ingest job with small test dataset..."
          python -m jobs.ingest --skus 20 --locations 2 --weeks 26

      - name: Run preprocessing job
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGDATABASE: smart_inventory
          PGUSER: postgres
          PGPASSWORD: postgres
        run: |
          echo "Running preprocess job..."
          python -m jobs.preprocess

      - name: Run baseline training job
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGDATABASE: smart_inventory
          PGUSER: postgres
          PGPASSWORD: postgres
        run: |
          echo "Running train_baseline job..."
          python -m jobs.train_baseline --horizon 2

      - name: Run policy computation job
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGDATABASE: smart_inventory
          PGUSER: postgres
          PGPASSWORD: postgres
        run: |
          echo "Running compute_policy job..."
          python -m jobs.compute_policy

      - name: Test API authentication
        run: |
          echo "Testing authentication endpoint..."
          
          # Mint JWT token
          TOKEN_RESPONSE=$(curl -s -X POST http://localhost:3000/auth/token \
            -H "Content-Type: application/json" \
            -d '{"username":"viewer","password":"viewer123"}')
          
          echo "Token response: $TOKEN_RESPONSE"
          
          TOKEN=$(echo $TOKEN_RESPONSE | jq -r '.token')
          
          if [ "$TOKEN" == "null" ] || [ -z "$TOKEN" ]; then
            echo "ERROR: Failed to mint token"
            exit 1
          fi
          
          echo "Successfully minted token"
          echo "TOKEN=$TOKEN" >> $GITHUB_ENV
          
          # Test /auth/me endpoint
          ME_RESPONSE=$(curl -s -H "Authorization: Bearer $TOKEN" http://localhost:3000/auth/me)
          echo "Auth me response: $ME_RESPONSE"
          
          if echo "$ME_RESPONSE" | jq -e '.user.role == "viewer"' > /dev/null; then
            echo "✓ /auth/me endpoint working correctly"
          else
            echo "✗ /auth/me endpoint failed"
            exit 1
          fi

      - name: Test protected endpoints
        run: |
          echo "Testing protected endpoints..."
          
          # Test /forecasts endpoint
          echo "Testing /forecasts endpoint..."
          FORECASTS_RESPONSE=$(curl -s -H "Authorization: Bearer ${{ env.TOKEN }}" \
            "http://localhost:3000/forecasts?latest_only=true&limit=5")
          
          echo "Forecasts response: $FORECASTS_RESPONSE"
          
          # Check if response contains data
          FORECAST_COUNT=$(echo "$FORECASTS_RESPONSE" | jq -r '.data | length')
          RUN_ID=$(echo "$FORECASTS_RESPONSE" | jq -r '.meta.run_id // "N/A"')
          
          echo "Forecast count: $FORECAST_COUNT"
          echo "Run ID: $RUN_ID"
          
          if [ "$FORECAST_COUNT" -gt 0 ]; then
            echo "✓ /forecasts endpoint returned data (count: $FORECAST_COUNT, run_id: $RUN_ID)"
          else
            echo "⚠ /forecasts endpoint returned no data (this may be expected if jobs haven't completed)"
          fi
          
          # Test /recommendations endpoint
          echo "Testing /recommendations endpoint..."
          RECS_RESPONSE=$(curl -s -H "Authorization: Bearer ${{ env.TOKEN }}" \
            "http://localhost:3000/recommendations?latest_only=true&limit=5")
          
          echo "Recommendations response: $RECS_RESPONSE"
          
          REC_COUNT=$(echo "$RECS_RESPONSE" | jq -r '.data | length')
          REC_RUN_ID=$(echo "$RECS_RESPONSE" | jq -r '.meta.run_id // "N/A"')
          
          echo "Recommendation count: $REC_COUNT"
          echo "Run ID: $REC_RUN_ID"
          
          if [ "$REC_COUNT" -gt 0 ]; then
            echo "✓ /recommendations endpoint returned data (count: $REC_COUNT, run_id: $REC_RUN_ID)"
          else
            echo "⚠ /recommendations endpoint returned no data (this may be expected if jobs haven't completed)"
          fi

      - name: Show container logs on failure
        if: failure()
        run: |
          echo "=== PostgreSQL logs ==="
          docker compose logs postgres
          echo "=== API logs ==="
          docker compose logs api

      - name: Cleanup
        if: always()
        run: |
          docker compose down -v
