name: CI

on:
  push:
    branches:
      - main
      - 'feature/**'
  pull_request:
    branches:
      - main
      - 'feature/**'

jobs:
  ci:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [20.x]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Setup Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: 'jobs/requirements.txt'

      - name: Install Node.js dependencies
        run: npm ci

      - name: Type-check and build API
        run: |
          npm run build

      - name: Install Python dependencies
        run: |
          pip install -r jobs/requirements.txt

      - name: Start PostgreSQL
        run: |
          docker compose up -d postgres
          sleep 5

      - name: Apply database migrations
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGDATABASE: smart_inventory
          PGUSER: postgres
          PGPASSWORD: postgres
        run: |
          ./scripts/db_init.sh

      - name: Build and start API container
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGDATABASE: smart_inventory
          PGUSER: postgres
          PGPASSWORD: postgres
          JWT_SECRET: ci-test-secret-do-not-use-in-production-12345678901234567890123456789012
          JWT_ISSUER: smart-inventory
          JWT_EXPIRES_IN: 12h
          VIEWER_USERNAME: viewer
          VIEWER_PASSWORD: viewer123
          OPERATOR_USERNAME: operator
          OPERATOR_PASSWORD: operator123
        run: |
          # Copy CI environment variables
          cp .env.ci .env
          docker compose build api
          docker compose up -d api

      - name: Wait for API health
        run: |
          echo "Waiting for API to be healthy..."
          for i in {1..30}; do
            if curl -f http://localhost:3000/health > /dev/null 2>&1; then
              echo "API is healthy!"
              break
            fi
            if [ "$i" -eq 30 ]; then
              echo "ERROR: API did not become healthy"
              docker compose logs api
              exit 1
            fi
            echo "Waiting... (attempt $i/30)"
            sleep 2
          done

      - name: Run data ingestion job (small dataset for CI)
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGDATABASE: smart_inventory
          PGUSER: postgres
          PGPASSWORD: postgres
        run: |
          echo "Running ingest job with small test dataset..."
          python -m jobs.ingest --skus 20 --locations 2 --weeks 26

      - name: Run preprocessing job
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGDATABASE: smart_inventory
          PGUSER: postgres
          PGPASSWORD: postgres
        run: |
          echo "Running preprocess job..."
          python -m jobs.preprocess

      - name: Run baseline training job
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGDATABASE: smart_inventory
          PGUSER: postgres
          PGPASSWORD: postgres
        run: |
          echo "Running train_baseline job..."
          python -m jobs.train_baseline --horizon 2

      - name: Run policy computation job
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGDATABASE: smart_inventory
          PGUSER: postgres
          PGPASSWORD: postgres
        run: |
          echo "Running compute_policy job..."
          python -m jobs.compute_policy

      - name: Test API authentication
        run: |
          echo "Testing authentication endpoint..."
          
          # Mint JWT token
          TOKEN_RESPONSE=$(curl -s -X POST http://localhost:3000/auth/token \
            -H "Content-Type: application/json" \
            -d '{"username":"viewer","password":"viewer123"}')
          
          echo "Token response: $TOKEN_RESPONSE"
          
          TOKEN=$(echo $TOKEN_RESPONSE | jq -r '.token')
          
          if [ "$TOKEN" == "null" ] || [ -z "$TOKEN" ]; then
            echo "ERROR: Failed to mint token"
            exit 1
          fi
          
          echo "Successfully minted token"
          echo "TOKEN=$TOKEN" >> $GITHUB_ENV
          
          # Test /auth/me endpoint
          ME_RESPONSE=$(curl -s -H "Authorization: Bearer $TOKEN" http://localhost:3000/auth/me)
          echo "Auth me response: $ME_RESPONSE"
          
          if echo "$ME_RESPONSE" | jq -e '.user.role == "viewer"' > /dev/null; then
            echo "✓ /auth/me endpoint working correctly"
          else
            echo "✗ /auth/me endpoint failed"
            exit 1
          fi

      - name: Test protected endpoints
        run: |
          echo "Testing protected endpoints..."
          
          # Test /forecasts endpoint
          echo "Testing /forecasts endpoint..."
          FORECASTS_RESPONSE=$(curl -s -H "Authorization: Bearer ${{ env.TOKEN }}" \
            "http://localhost:3000/forecasts?latest_only=true&limit=5")
          
          echo "Forecasts response: $FORECASTS_RESPONSE"
          
          # Check if response contains data
          FORECAST_COUNT=$(echo "$FORECASTS_RESPONSE" | jq -r '.data | length')
          RUN_ID=$(echo "$FORECASTS_RESPONSE" | jq -r '.meta.run_id // "N/A"')
          
          echo "Forecast count: $FORECAST_COUNT"
          echo "Run ID: $RUN_ID"
          
          if [ "$FORECAST_COUNT" -gt 0 ]; then
            echo "✓ /forecasts endpoint returned data (count: $FORECAST_COUNT, run_id: $RUN_ID)"
          else
            echo "⚠ /forecasts endpoint returned no data (this may be expected if jobs haven't completed)"
          fi
          
          # Test /recommendations endpoint
          echo "Testing /recommendations endpoint..."
          RECS_RESPONSE=$(curl -s -H "Authorization: Bearer ${{ env.TOKEN }}" \
            "http://localhost:3000/recommendations?latest_only=true&limit=5")
          
          echo "Recommendations response: $RECS_RESPONSE"
          
          REC_COUNT=$(echo "$RECS_RESPONSE" | jq -r '.data | length')
          REC_RUN_ID=$(echo "$RECS_RESPONSE" | jq -r '.meta.run_id // "N/A"')
          
          echo "Recommendation count: $REC_COUNT"
          echo "Run ID: $REC_RUN_ID"
          
          if [ "$REC_COUNT" -gt 0 ]; then
            echo "✓ /recommendations endpoint returned data (count: $REC_COUNT, run_id: $REC_RUN_ID)"
          else
            echo "⚠ /recommendations endpoint returned no data (this may be expected if jobs haven't completed)"
          fi

      - name: Show container logs on failure
        if: failure()
        run: |
          echo "=== PostgreSQL logs ==="
          docker compose logs postgres
          echo "=== API logs ==="
          docker compose logs api

      - name: Cleanup
        if: always()
        run: |
          docker compose down -v
